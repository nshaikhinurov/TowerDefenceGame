<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8"/>
    <title>TD</title>
    <!-- TODO: to get rid of the code like that, put it to a different CSS file -->
    <style>
        * {
            padding: 0;
            margin: 0;
        }
    </style>
    <!-- TODO: if you don't use build tools, use CDN link instead like the next line -->
    <script src="https://github.com/photonstorm/phaser-ce/releases/download/v2.9.4/phaser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.18.1/math.min.js"></script>
    <script src="js/styles.js"></script>
    <script src="js/inits.js"></script>
</head>

<body>
<!-- TODO: to put the code to a different JS file -->
<script>
    // TODO: if you use ES5, 'use strict' and the beginning of the file
    // TODO: to use only let and const instead of var
    var game = new Phaser.Game(1280, 720, Phaser.AUTO, null, {
        preload: preload,
        create: create,
        update: update
    });

    // TODO: to replace with arrow function
    // TODO: to get rid of this for functional-based style
    var TD = new function () {
        var gold;
        var wave;

        Object.defineProperty(this, "gold", {
            get: function () {
                return gold;
            },
            set: function (value) {
                gold = value;
                this.goldText.setText(this.gold.toFixed());
            }
        });

        Object.defineProperty(this, "wave", {
            get: function () {
                return wave;
            },
            set: function (value) {
                wave = value;
                this.waveText.setText('Wave: ' + this.wave);
            }
        });

        this.init = function () {
            this.gold = 100;
            this.wave = 0;
        }
    };

    // TODO: in ES5 it's safer to put all variables before the functions
    var wayPoints = [];
    var textures = {};
    var buildingTower;
    var isBuildingTower;

    function preload() {
        game.scale.scaleMode = Phaser.ScaleManager.NO_SCALE;
        game.scale.pageAlignHorizontally = true;
        game.scale.pageAlignVertically = true;
        game.stage.backgroundColor = '#eee';
    }

    function create() {
        game.physics.startSystem(Phaser.Physics.ARCADE);

        setWayPoints();
        createTextures();
        initWay();
        initCastle();
        initTowers();
        initSidebar();
        TD.init();
        startNextWave();
    }

    function update() {
        game.physics.arcade.overlap(TD.towers, TD.enemies, attackEnemies, checkTrueOverlapping);
        updateEnemyLifebars();
        updateTargets();
        if (isBuildingTower) {
            buildingTower.x = game.input.x;
            buildingTower.y = game.input.y;
            if (game.input.activePointer.isDown) {
                activateTower(buildingTower);
            }
        }
    }

    // TODO: functions' names should be clear and mirrors the meaning, i.e. doesTowerSeeEnemy or isEnemyVisibleForTower
    function checkTrueOverlapping(tower, enemy) {
        var overlapped = game.physics.arcade.distanceBetween(tower, enemy) < tower.range + enemy.size / 2;
        if (tower.focusedEnemy === enemy && !overlapped)
            tower.focusedEnemy = null;
        return overlapped;
    }

    function attackEnemies(tower, enemy) {
        // TODO: to add brackets even for one-line if ans else branches (not only for if-else clause)
        if (enemy.focusable)
            tower.focusedEnemy = tower.focusedEnemy || enemy;
        else
            return;

        if (tower.focusedEnemy !== enemy)
            return;

        enemy.hp -= tower.attack;
        // TODO: console.log shouldn't be placed in your production version
        console.log(enemy.name + ' attacked by ' + tower.name + ': -' + tower.attack);
        if (enemy.hp <= 0) {
            TD.gold += enemy.fullHp * 0.05;
            tower.focusedEnemy = null;
            killEnemy(enemy);
            console.log(enemy.name + ' killed by ' + tower.name);
        }
    }

    function updateEnemyLifebars() {
        for (var i = 0; i < TD.enemies.total; i++) {
            var enemy = TD.enemies.getChildAt(i);
            var lifebar = enemy.lifebar;
            lifebar.x = enemy.x;
            lifebar.y = enemy.y;
            lifebar.width = lifebar.height = (enemy.size * 0.5) * enemy.hp / enemy.fullHp;
        }
    }

    function updateTargets() {
        for (var i = 0; i < TD.towers.total; i++) {
            var tower = TD.towers.getChildAt(i);
            if (tower.focusedEnemy) {
                if (tower.focusedEnemy.alive)
                    checkTrueOverlapping(tower, tower.focusedEnemy);
                else
                    tower.focusedEnemy = null;
            }
            if (areCrossesEnabled) {
                var cross = tower.tcross;
                // TODO: to set your js and css style, check linters, i.e. ESLint for js
                // TODO: ternary operator ?: should have its branches on the next lines
                cross.x = tower.focusedEnemy 
                    ? tower.focusedEnemy.x - baseEnemyInfo.size / 2 
                    : tower.x;
                cross.y = tower.focusedEnemy 
                    ? tower.focusedEnemy.y 
                    : tower.y;
            }
        }
    }

    function killEnemy(enemy) {
        enemy.focusable = false;
        enemy.moveTween.stop();
        var killTween = game.add.tween(enemy);
        killTween.to({
            width: 2 * enemy.size,
            height: 2 * enemy.size,
            alpha: 0
        }, 200, Phaser.Easing.Linear.None);
        killTween.onComplete.addOnce(function () {
            enemy.kill();
            enemy.lifebar.kill();
            TD.enemies.remove(enemy);
            if (!TD.enemies.total)
                setTimeout(startNextWave, 1000 * nextWaveTimeout);
        }, this);
        killTween.start();
    }

    function attackCastle(enemy) {
        console.log(enemy.name + ': ' + enemy.hp);
        TD.castle.hp -= enemy.hp;
        killEnemy(enemy);
        if (TD.castle.hp <= 0)
            gameOver();
    }

    function startNextWave() {
        TD.wave++;
        baseEnemyInfo.speed *= 1.05;
        var waveEnergy = 2 + TD.wave;
        TD.enemies = game.add.group();

        for (var i = 0; waveEnergy > 0; i++) {
            var creepInfo = generateCreep();

            /* 
             * TODO: for the readability, use (
             *     parameters     
             * )
             * TODO: also think of dangling comma, it's suitable for code editing
             */
            var newEnemy = initEnemy(
                styles.sidebarWidth + styles.worldPadding,
                -styles.worldPadding - i * (creepInfo.size / 2 + creepInfo.margin), 
                creepInfo
            );
            game.physics.enable(newEnemy, Phaser.Physics.ARCADE);

            TD.enemies.add(newEnemy);

            var lifebar = game.add.sprite(0, 0, textures.lifebar);
            lifebar.anchor.set(0.5);
            newEnemy.lifebar = lifebar;

            move(newEnemy);
        }

        // TODO: do not do that (ESLint prevents it)
        enemyN = 0;

        function move(enemy, i) {
            // TODO: check ES6 default parameters
            i = i === undefined ? 0 : i;
            if (i >= wayPoints.length) {
                attackCastle(enemy);
                return;
            }
            
            var moveTween = game.add.tween(enemy);
            enemy.moveTween = moveTween;
            // TODO: it's not readable at all, try this
            moveTween.to(
                { x: wayPoints[i].x, y: wayPoints[i].y }, 
                game.physics.arcade.distanceBetween(enemy, wayPoints[i]) / enemy.speed * 1000, 
                Phaser.Easing.Linear.None
            );
            moveTween.onComplete.addOnce(function () {
                move(enemy, ++i)
            }, this);
            moveTween.start();
        }

        function generateCreep() {
            var maxType = math.min(4, waveEnergy);
            var type = TD.wave % 5 === 0 ? 5 : math.randomInt(1, maxType + 1);
            waveEnergy -= type;
            // TODO: why don't use var creep = Object.assign({}, baseEnemyInfo, { type: type }); ?
            var creep = {};
            Object.assign(creep, baseEnemyInfo);
            creep.type = type;
            switch (type) {
                case 2:
                    creep.hp *= 2;
                    creep.speed /= 1.5;
                    break;
                case 3 :
                    creep.hp /= 1.5;
                    creep.speed *= 2.5;
                    break;
                case 4 :
                    creep.hp *= 5;
                    creep.speed /= 1.5;
                    break;
                case 5:
                    waveEnergy += type;
                    creep.hp *= waveEnergy * 1.5 + (math.sqrt(waveEnergy) - 1 ) / creep.speed * 2;
                    creep.speed /= waveEnergy / 2.5;
                    waveEnergy = 0;
                    break;

            }
            creep.hp = math.round(creep.hp);
            creep.fullHp = creep.hp;
            return creep;
        }
    }

    function buyTower() {
        if (TD.gold >= baseTowerInfo.price) {
            TD.gold -= baseTowerInfo.price;
            var newTower = game.add.sprite(game.input.x, game.input.y, textures.tower);
            newTower.anchor.set(0.5);
            game.physics.enable(newTower, Phaser.Physics.ARCADE);
            buildingTower = newTower;
            isBuildingTower = true;
        }
    }

    function activateTower(tower) {
        isBuildingTower = false;
        Object.assign(tower, baseTowerInfo);
        if (areCrossesEnabled) {
            var cross = game.add.sprite(tower.x, tower.y, textures.cross);
            cross.anchor.set(0.5);
            tower.tcross = cross;
        }
        TD.towers.add(tower);
    }

    function gameOver() {
        alert('You lose! Castle HP = ' + TD.castle.hp);
        location.reload();
    }
</script>
</body>

</html>